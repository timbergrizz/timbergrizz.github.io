---
title: NEST - Controller
feed: show
---

# Controller
- Nest는 모듈 시스템을 기반으로 동작한다.
	- 익스프레스에선 app.js에 엄청나게 많은 미들웨어를 추가하는 방식으로 실행했다.
		- Router 위주의 설계로 구성되었다.
	- App Module에 추가적인 모듈들을 추가하는 방식으로 import하여 작동시키게 된다.
		- ```app.module.ts```의 import에 포함시켜 작동시킬 수 있다.
			- 이러면 파악해서 실행시키게 된다.
		- 콘솔 메시지에 import 관계가 명시되기 때문에 콘솔을 잘 확인해야 한다.
- Controller 위치를 바꾸고싶다면 ```@Controller``` 파라미터에 명시해주면 된다.
	- 많은 것들을 import하기 때문에 자동으로 import되는 것을 사용하는 것이 좋다.
	- Decorator 하위에 명시하는 방식으로 세부 주소를 정의할 수 있다.
		- 함수만 선언해도 라우터가 연결될 수 있다.
		- Decorator 또한 함수이며, 표현을 다르게 하여 Nest가 인식할 수 있도록 한다.
		- 매개변수에도 데코레이터를 추가해 기능을 추가할 수 있다.
- dependency 추가하는 것을 항상 해주어야 한다.
	- 추가를 안하면 당연히 문제가 발생한다.
		- 대부분의 경우 Nest가 추가 안했다는 것을 콘솔을 통해 명시한다.
	
- 컨트롤러는 라우터랑 연결할 수 있는데, 서비스라는 것이 추가된다.
	- 서비스는 들어가보면 동작이 정의되게 된다.
	- 익스프레스와 달리 서비스와 컨트롤러가 분리되어 있다.
		- 이는 비즈니스 로직과 라우팅을 분리할 수 있다는 점에서 이점이 있다.
		- Router가 해야하는 동작은 서비스에 넣고, 컨트롤러는 서비스를 실행한 후 결과값만 받아 반환해준다.
			- 테스트 과정에서 편리함이 생기게 된다.
	- 컨트롤러를 DB의 transaction 단위로 생각해도 좋다.
		- 하나의 서비스가 실행되는 단위를 서비스로 묶고, 이를 바탕으로 컨트롤러에서 호출하도록 하는 것이다
	- service는 요청, 응답에 관한 데이터는 알 수 없다.
		- 이러한 것을 분리하는 것에 이점이 있다.
		- 서비스에서는 해야하는 동작만 수행하고, 다시 컨트롤러로 돌려주는 구조가 된다.
	- 컨트롤러는 요청, 응답에 관한 데이터를 알고 있다.
		- 서비스에서 결과를 받아서 결과를 response로 보내주게 된다.
		- 요청을 조작해서 서비스로 넘겨주는 등의 역할을 한다

- 익스프레스는 다음과 같이 구성된다.
	- 위에 요청받는 부분이 있다.
	- 요청을 조작하는 부분이 있다.
	- 요청에 대해 처리하는 비즈니스 로직이 존재한다.
		- 여기의 비즈니스 로직만 서비스로 분리하여 구조를 단순화시킨 것이다.
			- 로직의 중복 재사용에 대한 제거 등에서 이점이 있다.
	- 결과에 대해 응답을 수행한다.
- express는 모든 미들웨어에 대해 요청, 응답, 콜백을 정의해야 한다.
		- 서비스는 일반 비동기 함수이기 때문에 mocking을 수행할 필요가 없다.
			- 하나의 함수만 테스트하면 된다.
			- 테스트가 편리하고 재사용하기 쉽다.
	- 익스프레스도 서비스처럼 다음과 같이 분리하면 되는거 아닌가?
		```ts
		async function finduser(email){
			return User.findOne({email});
		
		async (req, res, next) => {
			const user = await findUser(req.body.email);
			res.json(user);
		}
		```
		- 익스프레스에서도 이렇게 사용할 수는 있는데, 직접 만드는 것과 구현되어 있는 것을 사용하는 것은 차이가 크다.
			- 철저하게 이러한 규칙이 지켜지는가에 있어서 차이가 발생하게 된다.
				- 익스프레스는 사람에 따라 규칙의 적용이 달라지게 되고, 따라서 문제가 된다.
				- Nest를 사용하면 규칙을 사용하는 것이 기본값이므로, 이러한 점에서 구조의 강제성이 있다.

- 미들웨어 하나로 모든 것을 처리하던 익스프레스와, 미들웨어 각각의 기능을 쪼개 요소를 따로 만든 편리해진다.
- 응답이 중복되는데, 익스프레스에서 이러한 공통적인 데이터를 처리하기 애매하다
	- Nest에서는 함수를 만들지 않고, 이를 interceptor가 알아서 처리하도록 할 수 있다.
	- 미들웨어가 모든 것을 처리하는 것이 아닌, 일부가 처리하는 것이 되는 것이다.

- 또한, 컨트롤러를 통해 일반함수처럼 테스트를 할 수 있다.
	- 익스프레스는 미들웨어는 mock req/res가 존재해야 하는데 이러한 문제를 해결할 수 있다.
- request, response를 통해 응답을 받고, 리턴을 보내는 설계가 좋지 않다.
	- 함수에서 데이터만 리턴하면 처리될 수 있도록 하는 것이 좋은 설계라고 할 수 있다.
	- express에서는 굳이 따로 req, res를 넣어주어야 한다.
- nest는 express와 설계 자체가 다르다.
	- express 다음 세대의 설계를 도입하게 한다.

## Module and Controller
- express 강의에서 사용했던 라우터들을 그대로 옮겨보자.
	- [[NEST - TypeORM]]도 알아야 세부적으로 사용할 수 있기 때문에 모두 옮기지는 않겠지만, 일단은 해보자.
- [[NEST - API Documentation]] (Swagger 자동 생성) / decorator 쓰는거 중심으로 한번 알아보자.
- Nest에서는 다음과 같이 ```nest generate``` 명령어를 통해 자동으로 파일을 생성하고 import할 수 있다.![[Screenshot 2022-10-07 at 16.19.40.png]]
	- app.module.ts에 자동으로 연결된 것을 확인할 수 있다.![[Screenshot 2022-10-07 at 16.20.10.png]]
- 다음과 같이 controller 클래스를 만들 수 있다.
	```ts
	import { Controller, Get, Post } from '@nestjs/common';

	@Controller('users')
	export class UsersController {
	    @Get()
	    getUsers() {}
	
	    @Post()
	    postUsers() {}
	
	    @Post(`login`)
	    login() {}
	
	    @Post('logout')
	    logout() {}
	}
	```
	- 프론트에서 주소에 데이터 / 쿼리 / 파일 등을 같이 보낼 수 있다.
	- 어떨 것을 받을지 생각해볼 필요가 있다.
	- getUsers에서는 지금 로그인한 사용자 정보를 가져오는 api이다.
	
- Nest에서는 어떤 프레임워크를 쓰는지 중요하지 않도록 설계해야 한다.
	- 최대한 다른 프레임워크에 의존성을 가지지 않도록 설계하는 것이 좋다.
- Nest에서 기반 프레임워크는 중요하지 않다.
	- 나중에 다른 프레임워크가 붙어도 작동에 지장이 없도록 최대한 설계해야 한다.
	- 컨트롤러에는 최대한 request 안쓰는게 좋다는 뜻이다.;
- 내부적으로 이루어지는 프로세스에 대해 의문을 가지지 않아도 된다.
	- 원리는 알아야 하는데 구체적인 구현을 알 필요는 없다.
- Nest에서는 export default가 아닌 export를 사용하고, interface가 아닌 class를 사용하여 export한다.
	- interface는 typescript에만 존재하고, 컴파일 이후 사라진다.
	- 클래스는 js로 바뀐 후에 런타임에도 남아있기 때문에 이렇게 작동하는 것이 적절할 수 있다.
- DTO를 만들때의 장점이 많다.