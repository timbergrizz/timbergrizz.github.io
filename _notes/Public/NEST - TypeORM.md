---
title: NEST - TypeORM
feed: show
---

# TypeORM
- TypeORM은 Nest.js에서 사용되는 [[NEST - ORM]]이다.
- Sequelize에서 DB를 연결할 때 Sequelize-auto를 이용하여 자바스크립트 속성과 연동했다.
	- typeORM은 TypeORM-model-generator를 사용한다.
		- DB의 테이블을 참조하여 자바스크립트 객체형으로 만들어준다.
- Entity가 테이블에 대응되는 개념이라 할 수 있다.
- model-generator를 이용해 entity를 생성한 후, entity가 모델을 잘 표현하고 있는지 확인해야 한다.
	- 굳이 index같은건 확인할 필요 없다.
- ORM의 장점으로, 매핑이 되어 있으면 굳이 db의 속성 이름을 따라갈 필요 없이, 원하는대로 데이터를 설정하여 처리할 수 있다.
	- SQL과 자바스크립트의 표현법이 다르기 때문에, 이를 호환시키기 위해 유용하다.
- Entity 데코레이터를 빼고 보면 단순한 컬럼과 속성들이지만, Entity 데코레이터가 이를 완성시켜준다.
- Class로 생성되어서 좋은 점은, 겹치는 부분들은 상속을 통해 중복 제거를 할 수 있다.

## 관계 설정
- 객체 간의 관계를 설정하는 것이 중요하게 작용할 수 있다.
	- 슬랙 기준으로 workspace 하나가 여러개의 channel을 가질 수 있는 등의 관계가 발생하게 된다.
- decorator를 통해 이러한 관계를 표현할 수 있다.
	- 관계 설정할땐 반대에도 동일하게 생성해주어야 한다.
- Join 관계도 붙일 수 있는데, 일반적으로 Foreign Key가 속성으로 있는 곳에 붙인다.
	- one-to-many이면 many인 쪽에 붙여야 한다.
	- 슬랙 관계에서, 내 채널이 어떤 워크스테이션에 속하는지 명시할 수 있어야 한다.
	- 이렇게 연결하면, foreign key를 매개로 자동으로 join하여 작동한다.
- 반대로도 작동할 수 있다.
	- 상호간에 설정을 해두었기 때문에, 나누어진 채널에 따라 동작시킬 수 있다.
	- 관계 파악을 한 이후 데코레이터를 이용해 객체 간의 연결을 수행할 수 있다.

- ManyToMany같은 관계는 헷갈릴 수 있다.
	- 슬랙 기준 workspace와 user가 many to many 관계라 할 수 있다.
	- user는 여러개의 workspace에 들어갈 수 있고, workspace도 여러 명의 user를 수용할 수 있다.
	- many to many에서 버그 발생하면, one to many 여러개로 나누어 작동시켜도 된다.
- Join을 통해 중간 테이블이 발생할 수 있다.
	- JoinTable은 둘 중 하나에만 넣으면 된다.
	- many to many에서는 둘 중 하나에만 적당히 넣으면 된다.
- 관계들을 모두 설정하면 나중에 쿼리 날릴때 알아서 join해주고 편해진다.
- typeorm의 핵심은 column 설정의 간편함 등이다.
	- 조금 더 깔끔하게 TypeORM이 제공하는 기능들을 알고싶으면 공식 문서를 읽어 보면 좋다.
- soft delete등의 기능도 typeorm에서 지원된다.

- 한번에 여러 테이블을 수정하는건 위험하다.
	- 지원은 되는데, cascade를 통해 작동시켜야 한다.
- JPA와 거의 동일하게 작동한다.
- Entity에 Swagger 같이 넣으면 표현까지 잘 뽑힌다.
- Nest가 entity 자체를 DTO로 인식해준다.

- 놀랍게도 CRUD 자동으로 만들어주는 것도 존재한다.
	- co 하면 resource로 서비스까지 다 만들어준다.
	- Nest 도큐멘테이션 예제가 없어서 아쉬운거 빼면 다 .
- typeorm 연결하는건 공식문서 보고 잘 따라하면 된다. [공식 문서](https://docs.nestjs.com/recipes/sql-typeorm)
	- 상황에 맞게 변형해서 써야 한다. 드라이버같은거 제대로 설치해야 한다.
- 다음과 같이 TypeOrmModule을 import하여 사용할 수 있다. ![[Screenshot 2022-10-09 at 1.34.26.png]]
	- 이때 synchronize는 처음에만 수행하고 지워줘야 한다.
	- 또한, entity를 자동으로 인식하여 가져올 수도 있는데, 이것도 가끔 삑난다.
		- 폴더 단위로도 불러와지니까 이렇게 하는게 제일 무난할 것 같다.
- ```orm.config.ts```를 따로 만드는 것도 하나의 방법이다.
- ORM은 데이터가 복잡해질수록 비효율적인 코드를 짤 확률이 높아진다.
	- 개발할때는 무조건 로그 켜놓는 편이 좋다.
	- ORM이 어떤 테이블로 쿼리 날리는지 분석하고 튜닝하는 것이 좋다.
- orm.config.ts가 루트 디렉토리에 있는데, 이거 다른데 있으면 마이그레이션에서 오류 나서 저기 넣어둔거다.

- 로우 쿼리를 날려야 할 필요도 있는데, 이때는 그냥 찾아서 원하는 방법으로 날리면 된다.
	- active repository도 있다는 것 알아두면 좋다.
- ConfigModule을 이용해 .env 갖고와서 작동시키려면 다음과 같이 Module import를 수정하면 된다.![[Screenshot 2022-10-09 at 1.41.15.png]]
	- ConfigService에 대한 Inject가 이루어진 후, ConfigService를 사용할 수 있을 때 .env를 가져오도록 할 수 있다.
		- 우리가 환경 변수를 로컬이 아닌 다른 외부 비밀 저장소에 저장하는 케이스가 더 많고, 따라서 이렇게 비동기적으로 데이터 가져와서 사용하는 케이스가 더 많을 것이다.

## Seeding / Migration
- Seeding은 가짜 데이터를 삽입하는 과정이다.
	- typeomr-seeding이라는 라이브러리를 사용하여 작동시킬 수 있다.
- [faker](https://www.npmjs.com/package/@faker-js/faker)라는 라이브러리와 같이 사용되며 이를 살펴보는 것도 좋다.
	- seeding에 내장되어 있어서 빠르게 가짜 데이터를 생성할 수 있다.
	- 현재는 서비스를 위한 기본 데이터를 넣기 위함이므로 생각하지 않는다.
- 라이브러리를 확인하고, 정해진 위치에 맞추어 데이터를 삽입하여야 한다.
	- 인식 경로 바꾸기 위해서는 ormconfig.ts 설정 바꿔도 되긴 하는데 굳,,이...
- Migration은 테이블 등을 바꾸고 싶을 때 사용한다.
	- DB의 테이블을 수정하고 싶을 때 일반적으로 쿼리 사용하지만, 이렇게 바꾸면 DB 따로 Entity 따로 바꿔줘야 한다.
		- 여러개를 바꿔야 해서 귀찮다.
		- 실패시 불일치 문제가 발생할 수 있다.
	- Migration을 사용해 소스 코드로 테이블을 바꾸는 법을 알 수 있다.
		- Migration을 이용하면 오류가 발생할 때 rollback 기능도 있어서 좋다.
		- TypeORM이 migration할 때 쿼리를 자동으로 만들어준다.

- Extends를 이용해 Entity의 속성을 가져오고, 이를 바탕으로 중복을 제거하여 객체를 표현할 수 있다.
	- PickType 사용하면 좋다.
- 모듈이 있고, 그 뒤에 컨트롤러가 있다. 그리고 컨트롤러들이 서비스를 호출한다.
	- 서비스는 레포지토리를 통해 Entity에 쿼리를 날린다.
	- 서비스와 엔티티 사이를 레포지토리가 이어준다고 생각하면 된다.

## Transaction
- 회원가입을 수행하면 join이 이루어진다.
- 이때 로직을 살펴보면, 쿼리를 여러번 실행시키는 경우가 있다.
	- 이러한 로직 중 일부가 실패하면 신나는거다.
	- 그래서 여러개의 동작이 다같이 실행됨을 보장하기 위해 Transaction을 만들어서 하나의 단위로 취급하고 처리한다.
- TypeORM에서 Transaction을 사용하는 방법으로 총 3가지가 있다. [공식 문서](https://orkhan.gitbook.io/typeorm/docs/transactions)
	- transaction 한정으로 connection과 manager는 큰 차이가 없다.
	- 아니면 Method 위에 transaction이라는 데코레이터 붙여서 처리할 수 있다.
		- 이거 의존성주입 지랄같아져서 웬만하면 하지 말라고 한다. 공식 문서가 하지 말라는건 웬만하면 하지 말자.ㅌ
- 네스트에서는 라이브러리에서 바로 가져오는 것은 피해야 하는 패턴이다.
	- 그런 점에서 서비스에서 import하여 query-runner를 사용하여 transaction을 구현하는 것은 좋지 않은 방법이다.
		- connection 이용해서 typeorm으로 가져와서 사용하는게 베스트.
- try - catch 사이에 DB 다 때려박으면 될까?
	- 우리 커넥션 새로 만들었는데, 쿼리들이 새로운 커넥션을 통해서 실행될 것인지 설정된 TypeORM을 바탕으로 실행될 것인지에 따라 묶이는게 달라진다.
		- 슬프지만 다른 레포지토리로 가져온거 트랜젝션으로 안묶이고, Queryrunner로 가져와야 한다.


## QueryBuilder
- 쿼리가 복잡해지게 되면, 이걸 굳이 DTO로 구현할 방법을 찾을 필요가 없다.
	- SQL 형식으로 TypeORM에서 쿼리 빌더라는 형식을 만들어두었고, 이거 사용하면 된다.
- 처음부터 SQL의 모든 형식을 다 만들어둘 필요는 없다.
	- 필요하면 Join같은 관계를 추가핵가면서 쓰면 된다.
	- 근데 외래키로 연결된 애들은 그냥 묶어두고 가는 편이 좋다.
- getRowMany는 배열 형태로 나온다.
	- 이를 피하기 위해 자바스크립트 상에서 객체로 인식하여 만들어주는 GetMany를 사용할 수 있다.
	- 파싱이좀 느리긴한데, 성능 생각하면 지는게 ORM이다.
		- 성능이 중요하면 raw query 날리세요 인간.
- TypeORM은 기본적으로 join하면 join한 테이블을 가져오지 않는다.
	- Join할 때 innerJoinAndSelect로 처리해야 join한 테이블의 데이터까지 가져온다.
- TypeORM의 QueryBuilder를 이용해 SQL과 비슷한 흐름으로 가져갈 수 있다.
	- innerjoin만 수행하는 이유는, 조건문으로 필터링만 수행하되, workspace 정보를 가져오지 않을 때 사용한다.
	- 조건을 부여하는 많은 방법들이 있고, 이를 사용해서 적당히 적용하면 된다.


### TypeORM vs Sequelizer
- 결국 서비스가 복잡해지면 ORM으로 사용할 수 있는 메소드에 한계가 온다.
	- SequelizeQuery로 표현되지 않을 때가 있을 수 있다.
	- 그 중 QueryBuilder를 이용해 해결할 수 있는 부분들이 존재한다.
		- 한계는 있긴 한데, 조금 더 SQL과 비슷하게 처리할 수 있어 더 복잡한 쿼리를 다룰 수 있다.
- SQL과 거의 비슷한 구조로 사용할 수 있는 점이 더 좋다.
- [knex.js](https://knexjs.org/) 라는 query builder가 있는데 TypeORM을 사용하면 이러한 쿼리 빌더와 유사하게 사용할 수 있어 좋다.
	- 데코레이터들 때문에 js에는 조금 애매하다.
- 