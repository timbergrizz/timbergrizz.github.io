---
title: Micro Service Architecture and Service
feed: hide
---

## Monolithic Architecture

- 기존의 전통적인 웹 시스템 개발 스타일
- 하나의 애플리케이션 내에 모든 로직이 들어가있는 “하나의 프로그램” 구조
    - 온라인 쇼핑몰을 운영한다고 하자,.
        - 사용자 관리, 상품 / 주문 관리 등의 컴포넌트가 필요할 것이다.
        - 이러한 컴포넌트들과 이를 처리하는 UX 로직까지 하나로 포함되어 들어가 있는 구조를 의미한다.
            - 각 컴포넌트들은 상호 호출을 함수를 이용한 call-by-reference 구조를 이용한다.

### Problems of Monolithic Architecture
- 모노리틱 아키텍처 시스템은 다음과 같은 문제를 갖는다.
    - 규모가 큰 어플리케이션에서는 불리한 점이 많다.
        - 크기가 크기 때문에 빌드 / 배포시간, 서버의 기동 시간 등이 오래 걸린다.
        - 프로젝트를 진행하는 관점에서 일부 컴포넌트의 오류가 전체 시스템의 빌드 실패를 유발할 수 있다.
            - 협업 개발에 있어 어려움을 줄 수 있다.
        - 시스템 컴포넌트들이 로컬 콜 기반으로 타이트하게 연결되어, 전체 시스템 구조를 파악하지 못하면 성능 문제 / 장애가 다른 컴포넌트에 영향을 미칠 수 있다.
            - 전체 시스템을 이해해야 문제가 해결되는데, 시스템의 구조가 커질수록 개인이 이를 이해하는건 쉽지 않다.
        - 특정 컴포넌트를 수정하고자 했을 때, 컴포넌트 재배포시 전체 어플리케이션을 재컴파일하여 전체를 다시 배포해야한다.
            - 따라서 잦은 배포가 있는 시스템에서 불리하게 작용한다.
        - 컴포넌트별로 기능 / 비기능적 특성에 맞춰 다른 기술을 도입하고자 할때 유연하지 않다.
            - 현재 작동하는 어플리케이션을 Java로 작성했을 때 파일 업 / 다운로드 등 일부 기능을 Node.js로 사용하는 것이 좋다고 해도 이걸 적용하기가 어렵다.

### Pros and Cons
- 무조건 나쁘다는건 아니다.
    - 규모가 작은 어플리케이션에서는 배포가 용이하다.
    - 규모가 크더라도 call-by-ref call에 의해 성능 제약이 덜하며, 운영 관리가 용이하다.
    - 하나의 구조로 되어있기 때문에 트랜젝션 관리 등이 용이하다는 장점이 있다.
    - MSA만이 모든 상황에서 작동하는 정답은 아니고, 상황과 필요에 따라서 선택할 필요가 있다.

## Micro Service Architecture
-   Service Oriented Architecture(SOA)를 바탕으로 대용량 웹 서비스를 정의하기 위한 아키텍쳐이다.
    - SOA 사상에 근간을 두고, 대용량 웹 서비스에 맞도록 사상이 경량화되고, 대규모 개발 팀의 조직 구조에 맞도록 변형된 아키텍처이다.
- 기술이 왜 생겨났는지 원인을 생각해보면 좋다.
    - 어떤 것이든 왜라는게 없으면 이해하기 어렵다.
	- 소프트웨어 개발이 어떻게 변해왔는지 이해해야 한다.
		- 90년대에 it가 시작되고, 여러가지 인터넷 기업들이 나오고 인터넷이 보급된다.
		- 인터넷 기업들이 자신들의 기술을 풀어놓기 시작하고, 이게 오픈소스가 된다.
			- 서블릿, JSP등의 기술들이 시장에 나오기 시작한다.
			- 독점권들이 많아 기술이 공부하기 쉽지 않았다.
			- 소프트웨어를 바탕으로 돈을 벌기 어려웠다.
		- 스티브 잡스가 아이폰 들고나오면서 세상이 바뀌었다.
		    - 개인 개발자가 돈을 벌 수 있도록 하게 된것이다.
		    - 누구나 앱을 만들고 돈을 벌 수 있게 된 것이다.
		        - 스타트업이 생기기 시작한다.
		- 누구나 앱을 만들 수 있고, 하기 때문에, 새로운 기술을 빠르게 적용할 수 있어야 한다.
			- 기업형 어플리케이션은 시스템의 안정성 / 일관성이 중요했다.
			- 데이터가 깨지면 안된다.
			- 가용성 / integrity가 중요했다.
- 글로벌 서비스를 사용되면서 기존의 인프라를 바탕으로 서비스를 제공하기 어려워져 하둡 등의 연구되기 시작되었다.

### 아키텍처 구조

#### 서비스
- MSA에서는 각 컴포넌트를 서비스라는 개념으로 정의한다.
- 서비스는 데이터부터 비즈니스 로직까지 독립적으로 상호 컴포넌트 간의 의존성 없이 개발된 컴포넌트이다.
    - 일반적으로 REST API와 같은 표준 인터페이스로 그 기능을 외부로 제공한다.
- 서비스 경계는 구문 또는 도메인(업무)의 경계를 따른다.
    - 사용자 관리 / 상품 관리 / 주문 관리 등의 업무 별로 서비스를 나누어 정의할 수 있다.
    - 사용자 / 상품 관리 처럼 여러 개의 업무를 하나의 서비스로 엮어 정의하지 않는다.
    - REST API에서 주요 URI도 하나의 서비스 정의의 범위로 좋은 예가 된다.

#### 구조
- 각 컴포넌트는 서비스라는 형태로 구현되고, API를 이용해 타 서비스와 통신한다.
- 배포 구조 관점에서도 각 서비스는 독립된 서버로 타 컴포넌트와의 의존성 없이 독립적으로 배포된다.
    - 사용자 관리 서비스 등 여러가지 서비스는 자바 기준으로 독립적인 war 파일로 개발되어, 독립된 톰캣 인스턴스에 배치된다.
    - 확장을 위해서 서비스가 배치된 톰캣 인스턴스는 횡적으로 스케일이 가능하고, 앞단에 로드 밸런서를 배치하여 서비스간의 로드를 분산시킨다.
- 애플리케이션 로직을 분리하여 여러 개의 어플리케이션으로 나누어 서비스화하고, 각 서비스별로 톰캣을 분산 배치한 것이 핵심이다.

### 속도형 아키텍처
- 기존에는 팀을 만들 때 기능 단위로 팀을 만들었다.
    - 부서가 기능 단위로 분리되고, 개발도 부서 단위로 이루어져 있다
        - 각 파트간의 협업이 어렵다.
- 애자일 컨셉과 비슷해지는데, 기능 단위가 아닌, 서비스 단위로 팀을 만들게 되었다.
    - 팀에 모든 유닛이 다 들어가게 된다.
        - 의사 결정이 팀 내부에서만 발생하고, 승인이 필요 없어지게 된다.
    - 프로덕트 오너는 그 프로덕트를 책임지는 책임자라고 할 수 있다.
        - 모든 것을 결정하게 된다.
    - 모놀리식 아키텍처에서 이런 문화를 적용하기 어렵다.
        - 각각의 컴포넌트를 개발하되 개발에 대한 종속성을 제거하여 속도를 높일 수 있도록 하는 것이다.
- 항상 좋은 기술은 아니다.
    - 계좌 이체에서 transaction이 발생한다고 하자.
        - 컴포넌트 분리되고 db 분리되면서 신나진다.
        - 입금, 출금 같이 발생해야 하는데 둘 중 하나 죽으면 신나진다.
    - Data의 consistency가 중요하거나 빠르게 처리되어야 하는 경우 모놀리식 아키텍처가 사용되는 것이 좋다.
        - MSA도 하나의 옵션일 뿐, 무지성 MSA 하시면 안된다.

### 컨웨이의 법칙
- 소프트웨어 아키텍처의 구조는 소프트웨어를 구현하는 규칙을 따라간다.
	- 한국 / 인도 / 미국 / 캐나다가 팀을 이루고 있다고 하자.
	- MSA 아키텍처를 도입해야 할 때, 팀의 수준에 따라 아키텍처를 분배하고 처리했다.
		- 시간대가 같은 팀은 잘 연결된다.
		- 시간대가 떨어지면 연결이 잘 안된다.
	- 이론적으로 아키텍처를 잘 구분했다고 하더라도 문제가 발생할 수 있다.
- 컴포넌트를 어떻게 자르냐는 질문을 많이 받는데, 제일 모범적인 대답은 업무 별로 자르는 것이다.
	- 경험상 팀의 구조를 맞추어 설계하는 것이 맞다.
	- 컴포넌트를 만든 후 팀원들을 내려보내는 것은 아니다.
- 북스토어라는 곳에서 분리를 하는 것이다.
    - 기동형 / 속도를 높이는 개발형 프로세스를 설정했다.
        - 개발이 빨라져도 기동이 느려진다.
        - 운영과 개발을 합치기 위해 데브옵스가 등장했다.
            - 14년 전에 데브옵스 구분하는 걸 고민했다.
            - 데브옵스는 개발 / 운영팀을 합치는 과정이다.

### SRE
- 제대로 된 데브옵스는 뭐라 할 수 있을까?
	- 구글에서는 SRE라고 부르기도 한다.
	- 서버로 배포를 하는데, 이런 운영 과정을 엄청나게 오래 걸리도록 할 수 있다.
		- 요즘은 클라우드로 배포한다. 이미 플랫폼화 되어 있다.
	- 그러면, SRE팀은 뭘 하는가?
		- 개발된 서비스를 배포할 수 있는 플랫폼을 만드는 것이다.
		- 클라우드보다 좀 더 포장된 플랫폼을 만드는 것이다.
- 구글의 SRE 엔지니어는 다음과 같이 일한다.
    - 자동화 프로세스를 만든다.
        - CI/CD 하고, 오토메이션 만들고, 프로메테우스 만들다.
        - 이렇게 자동화되면 다른 팀으로 옮겨가 자동화를 시작한다.
    - 구글 클라우드에서 나온 서비스들은 구글 내부에서 동일하게 사용한다.
- 플랫폼을 만들기 위해서는 이를 만들기 위한 기반이 필요한다.
    - VM 기반은 표준이 없어 힘들다.
        - MS Hyper-v / KVM / 기타등등 많다.
        - 무겁고, 라이센스비도 들다.
    - 컨테이너가 나왔고, 이건 가볍고 벤더 종속도 안탄다.
        - 컨테이너를 어디 배포할지 지정해야 한다.
            - 이걸 컨테이너 오케스트레이션 시스템이라고 한다.
        - 구글만 쿠베를 지원했고, AWS는 아파치 기반 / 애저는 스왐 뭐시기 기반이었고, 쿠베가 통일했다.
            - 쿠베는 이렇게 시작되었다.
