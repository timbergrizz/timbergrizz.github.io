---
title: K8s - Week4
feed: hide
---

## CI / CD

- ArgoCD 쓰시는게 답입니다.
	- Continuous Integration : 코드 빌드가 자동적으로 이루어지는 것
	- Continuous Deployment : 자동으로 서비스로의 deployment가 이루어진다.
		- Delivery와는 사람의 개입 여부로 달라지게 된다. 
			- Delivery는 사람의 개입이 필요로 한다.
		- 코드가 자동으로 deployment되는것이 당연히 좋긴 한데, 소프트웨어 자체가 비즈니스이고, 결제가 필요한 경우가 있으므로 사람의 개입이 필요한 경우가 많다.
- System에 배포하기 위한 방법
	1. 하드웨어 : VM, 네트워크, 스토리지 등
	2. 미들웨어 : DB, Message Queue
	3. 소프트웨어 : 서비스.
		- 서비스는 다른 경우와 다르게 변경되는 경우가 많다.
- 인프라를 배포하는 것은, Terraform으로 이루어진다.
- DB / 미들웨어 배포는 보통 ansible로 일반적으로 배포된다.
	- 쿠버네티스 환경이 오면서 달라지게 된다.
		- 인프라는 리소스이고, pod라는 서비스가 되므로 helm이라는 것을 많이 사용하게 된다.
		- 리소스를 배포할 수 있는 기능이 생겨 인프라, 미들웨어를 배포하는 것도 helm을 주로 사용하게 된다.
- scaffold, argocd를 주로 사용하여 서비스에 대한 배포가 이루어지게 된다.

- 동일한 문서라고 해도, 지역에 따라 달라지게 된다.
	- 쿠버네티스 리소스에 대해 템플릿을 만들고, 이에 대한 yaml을 만들어내야 한다.
	- helm이 이러한 개념을 사용한다.

### Helm
- 이렇게 변수화 시켜서 아키텍처를 만들 수 있도록 한 것이다.![[Pasted image 20221025142306.png]]
	- 일종의 템플릿을 제공한다고 볼 수 있다.
	- 이러한 아키텍처에 대해 패키지화를 할 수 있다.
- 서비스간의 dependency를 갖는 경우가 있다.
	- 이러한 dependency도 명시하여 쿠버네티스에 작동시킬 수 있다.
	- 엄청 많이 쓴다.

- Helm 파일은 다음과 같이 구성된다.![[Pasted image 20221025142453.png]]
	- helm tiller가 예전엔 필요했는데 지금은 상관 없다.
- templete based package manager이다.
	- helm을 통해 한번에 올리고, 내리기 편해진다.
	- install hook 등을 가질 수 있다.
		- 인스톨 후에 실행 시킬 수 있는 것들을 hook을 통해 가능하게 할 수 있다.
- 개발 환경 표준에 helm 사용하면 편하다.
	- mysql같은거 쿠베한테 할 수 있게 차트 만들어주면 좋다.
- Helm은 좀 배워두세요

### CI
- jar 파일을 깃허브에 그대로 넣는건 권장하지 않는다.
- 대기업에서는 static analytics, open source analysis등을 사용하게 된다.
	- 소스 코드의 복잡도를 분석하고, 오픈 소스의 라이센스를 체크하는데 도움을 준다.
- 젠킨스는 CD 호소인이다.
	- 되긴 한데, 웬만하면 CI / CD툴은 분리해서 사용하는 것이 좋다.
	- CI는 물리적인 location이 분리되도록 하는 것이 좋다.
		- Enterprise는 소스 코드를 외부로 웬만하면 반출하지 않는다
			- CI는 회사 내부에서 일어나고, CD툴로 연동하여 밖으로 보내주게 된다.
- 눈송이는 같은게 하나도 없다.
	- 서버도 동일한게 하나도 없다.
		- 이걸 최대한 동일하게 세팅할 수 있도록 해야 한다.
		- 서버의 형상이 모두 달라지게 되는 패턴을 스노우 플레이크 패턴이라고 한다.
			- 이거 굉장히 문제가 될 수 있는 패턴이다.
	- 요즘같은 서비스는 수동으로 매니지먼트 할 수 없고, 스노우 플레이크 패턴이 발생한다.
		- 피닉스 패턴이라고 하는데, 죽으면 다시 태어난다.
			- 피닉스 서버 패턴은 쿠버네티스 나오기 전에 나왔다.
			- binary만 replace하는 것이 아닌, os부터 새롭게 다 배포하도록 하는 개념이다.
		- 배포 할 때 마다 인프라부터 미들웨어, 서비스가 패킹되기 때문에 달라지지 않는다.
- 컨테이너로 오면서 base image를 넣고, 피닉스 패턴이 자연스럽게 쿠버네티스 패턴으로 이루어지게 된다.
	- 일정한 상태의 바이너리를 만들 수 있게 된다.

### CD
- 자바면 jar 빌드하고, 컨테이너면 태그 바꾸고, 레포로 푸쉬하고, yaml 업데이트하고, dev env로 배포하고, 테스트 / 디버깅 한다.
	- 직접하면 복잡해서 못한다.
	- 클라우드 코드 쓰니까 지금은 편한데, 다른거 쓰면 좀 골때린다.
- Skaffold가 구글에서 만든 미니 cd 툴인데, 이러한 cd 파이프라인을 구성해준다.
	- 레포지토리에 소스코드 변화 발생하면 build하고 이를 올려주고, 올려서 따로 필요한 작업까지 다 해준다.
	- helm이 되고, kustomize되서 좋다.
		- kustomize는 configuration management tool이다.
			- helm이랑 비슷한데, 이건 일반적인 템플릿 매니저다.
	- skaffold는 프로파일 개념으로 작동시킬 수 있고, 상황에 따라 다르게 CD가 이루어지도록 설정할 수 있다.![[Pasted image 20221025144011.png]]
	- yaml 파일 예시![[Pasted image 20221025144051.png]]
	- skaffold는 plugable 아키텍처이다.
		- helm과 같이 사용하면 좋다.
			- skaffold는 버전이나 롤백이 아니고, helm은 빌드하고 배포하지는 않는다.
				- 두개를 같이 사용하는 것이 좋다.
		- 요즘은 argo쪽으로 정리되는 것 같다.
	- MSA는 배포 많이 하게 되고, skaffold로 배포하게 되면 신나게 되는거다.
		- tekton이라는게 나왔다.
			- 파이프라인의 각 프레임마다 레이블을 하도록 했지만, 성공하지는 못했다.
- argocd가 인터페이스가 잘 되어있고, 편해서 성공했다.
- 배포에는 여러가지 방식이 존재하고, CD툴도 이를 지원해주어야 한다.
	- Spinnaker라는 툴이 이러한 역할을 한다.
		- argocd의 advanced된 툴이라고 할 수 있다.
		- CD 파이프라인을 만들고, exectution 원하는 시간에 이루어질 수 있도록 한다.
		- 문서가 업데이트가 잘 안된다.
		- 그래도 툴 자체는 되게 좋다.
			- 삼성전자랑 샌드버드가 잘한다.
		- 시스템 규모가 크고 하면 러닝커브 높아도 써볼만한 툴이다.
- 클라우드 코드는 쓰고 있죠?
	- 무조건 쓰세요.
- kubernetes operator 찾아보세요.
	- 쿠버네티스 보면 deployment등 리소스를 정의하도록 할 수 있다.
	- saas등에서 많이 사용한다.
		- 여러개 정의하는 걸 하나로 abstract해준다.
		- 코드를 짜주는게 복잡하고, Golang으로 짜는데 요즘은 [kopf](https://github.com/nolar/kopf)라는거 많이 쓰더라.
	- helm은 꼭 보세요.
- CD를 고민할 때, 클라우드 빌드로 이루어지게 된다.
	- 빌드 자체도 자원을 많이 요구하고, jenkins job을 여러개 두고 인스턴스 크기가 점점 커진다.
	- maker 하나만 도는게 아니라 유닛 테스트까지 돌면 인스턴스 크기가 감당이 안된다.
		- 빌드 머신이 점점 커지게 되고, 한 빌드가 점점 많아지게 된다.
		- 클러스터 유지하는 것도 일이다.
	- 클라우드에 매니지드 서비스로 얹고 이거 클라우드에 돌도록 할 수 있다.
	- 아니면 젠킨스x같은거 써서 쿠버네티스에 job으로 띄우던가...
		- 작은 시스템은 vm 한두대 돌리면 되는데 msa로 나가고 시스템 규모 커지면 분산 시스템 만들어줘야 하는 거다.
		- 클라우드 쓰는게 짱이다.
			- 자원 관리 이쪽에서 알아서 다 해준다.
	- 빌드 과정에서도 재미있는 practice가 많다.
		- 빌드 박살나면 패널티를 주고, 패널티 높아지면 배포 전에 리뷰하는 등의 패널티를 준다.
			- 볼게 되게 많고, SRE의 한 분야로 점점 더 중요해지고 있다.

## Security
- user identity
	- 사람도 있지만 시스템도 유저로 본다.
		- 시스템 유저를 대표하는 것을 서비스 어카운트라 한다.
	- API에 대한 identification이 가능해야 한다.
		- service account를 identity로 준다.
- 쿠버네티스는 기본적으로 계정 관리 시스템이 없다.
	- 철저하게 id 관리 시스템을 외부 시스템을 사용하도록 한다.
	- packaging 서비스는 다 있다.
- service account를 인증을 걸도록 할 수 있다.

### Authentication
- 인증 방식이 중요하다.
	- 바닐라로 HTTP에 ID / Pass 넣으면 신난다.
	- 헤더에 넣어도 신난다.
	- 공인 인증서 방식을 사용하는 HTTPS 쓰는게 제일 좋다.
		- Certificate 방식으로 사용하는 것이 가장 안전하다.
		- 양방향 ssl 방식이라 안전하긴 하다.

### RBAC
- Resource Based Access Control
	- 각각의 pod에 Role에 따라 권한을 배치하는 방식이다.
	- role을 유저로 연결하는 방식이 role-binded가 된다.
- namespace
	- role은 namespace 내부에만 존재한다.
	- 롤을 만들면, tenant 안에만 존재한다.
		- 다른 namespace user한테 role 줄 수 있다.
		- 다른 프로젝트에 권한을 주어 접근 할 수 있도록 할 수 있다.
	- 운영 팀을 프로젝트에 있는 Role을 할당하도록 할 수 있다.

- 클러스터에 대한 Role을 부여할 수 있고, 이러한게 되게 많다.
	- 불편하게 하지 말라고 pre-defined role들이 있다.
		- 기존에 있는 pre-defined role 쓰는게 정신건강에 이롭다.

### Network Policy
- 방화벽!
- ingress등으로 들어오고 나가는 트래픽을 통제하는 것이다.
	- 보통은 ip로 컨트롤 하는데, 아웃바운드과 쿠베는 구분 가능한데, 쿠배 내부 서비스는 ip로 통제 안된다
		- 태그로 통제한다.
- 한번 해보시는게 제일 이해하기 편하다.
- port 단위 등으로 컨트롤 할 수 있다.
	- 레시피 있고, 이거 보는게 제일 좋다.
- 네트워크 정책 별로 쓸 필요 없다.
	- 인그레스 앞에 붙고, 내부 서비스 붙은 뒤에 pod로 이어지는 패턴이다.
		- L7 로드밸런서이기 때문에 ingress에서 방화벽 기능이 이미 존재하고, 내부 트래픽을 컨트롤할 일이 잘 없다.
		- 금융 요건 따르기 위해서 api 서버 / db 서버를 분리하도록 할 수는 있긴 하고, multi-tenancy에서 사용할 수 있다.
			- 통신 장비는 요즘 다 사실 소프트웨어 장비로 나온다.
				- 쿠버네티스 클러스터로 나오도록 할 수 있따.
- 알아만 두자.

### Security Context
- Pod가 돌 때 어떻게 작동시킬건지를 설정한다.
	- 도커파일 만들 때 run 시키는데, root 권한이 아닌 다른 user 권한으로 작동시키도록 하는 것이 좋다.
	- 다른 사람이 컨테이너 들어왔을 때 사고 안나도록 하려고 root로 동작하지 않도록 하면 좋다.
		- 어플리케이션에서 root 를 필요로 하면 튕겨버린다.
- kernal에 대한 접근 권한을 줄 수도 있다.
	- default는 커널 접근 가능하도록 하는 것이다.
		- 시스템 콜들을 막아 커널을 보호하도록 할 수도 있다.
		- app에서 노드에, vm에, 호스트에 권한을 막을 수 있다.
		- privileage등의 권한을 막도록 하여 설정할 수 있다.
		- 특정한 권한만 가질 수 있도록도 설정할 수 있다.
- 어플리케이션은 보통 개발자가 만든다.
	- Pod도 개발자가 같이 만들기 때문에, 커널 권한을 직접 요청할 수 있다.
	- 운영자 입장에선 권한을 주지 않을 수 있고, 쿠버네티스에서 보안 정책을 설정할 수 있다.
		- SRE가 줘서 커널 권한 접근을 못하도록 막는다.

### Pod Security Policy
- Privilege model을 접근하지 못하도록 막는 것이다.
	- 권한을 요청해도 막히게 된다.
	- 중앙 admin이 security policy를 만들어, 각 pod에 배포하는 방식으로 작동시킬 수 있다.

- 사실 별로 쓸 일은 없다.
	- root 권한 주는것도 별로다.
- 지금의 케이스는 결국 굉장히 중요한 보안 수준을 필요로 하는 경우이다.
	- [gVisor](https://gvisor.dev/)라는게 요즘 나와서 커널 분리하는 솔루션들이 있다.
		- kvm이라는걸 달아서 시스템 콜만 캐치할 수 있도록 한다.
		- 샌드박스 내부에서 동작할 수 있도록 할 수 있다.
	- 일종의 얇은 vm 레이어를 넣었다고 볼 수 있다.

- 마스터 노드 있고, 하단에 노드들이 붙을 때 마스터에 대한 ip 제어를 하는 것이 좋다.
	- 특정 대역폭에서만 접근할 수 있도록 방화벽을 세팅하는 것이 좋다.
	- 노드들은 public ip를 갖지 않는 것이 좋다.
- 밖에서 들어오는 트래픽은 service와 ingress를 통해서만 받도록 해야 한다.
- kubectl 있을때, certification으로 인증하는데, cert를 주기적으로 rotate해주는 것이 좋다.
	- fido key라는게 있고, 이거 찾아서 만들 수 있따.
		- 여기에 ip 인증 시스템을 등록해서 작동하도록 할 수 있다.
		- 등록된 디바이스에 키를 넣고 접근해야 접근할 수 있도록 할 수 있다.
	- 보안은 사실 사람 못막으면 못막는다.