---
title: Deploying with Kubernetes
feed: hide
---


출처 : [쿠버네티스로 배포하기 - Slash](https://blog.slashuniverse.com/16)
- 컨테이너로 배포하기 위해서는 기존 어플리케이션을 어떻게 컨테이너화 하는지가 문제이다.

## How to Containerize App
1. 지금 작업하고 있는 환경과 최대한 유사한 이미지를 찾아야 한다.
	- 이때 도커허브에서 verified된 이미지를 사용해야 한다.
	- alpine을 사용하면 더 가볍게 서빙을 할 수 있다.
2. 로컬에서 돌아가던 앱을 도커에서 돌린다.
	- Dockerfile을 사용해서 명시하자.
		- run을 통해 테스트를 해본 후, 이를 바탕으로 도커 파일 작성하면 된다.
	- 이때 사용하지 않는 이미지들은 정리하면 된다.
3. 이미지를 컨테이너 리포지토리로 배포한다.
	- 설정 파일 조심해라.

## Running on Kubernetes Cluster / Exposing the Service
- 도커 이미지로 띄웠으면 이걸 클러스터로 보낼 수 있다.
- 로컬 환경에서 minikube등의 환경 사용해서 테스트해볼 수 있다.
1. Deployment 작성하기
	- Deployment가 뭔지는 [[K8s - Service, Deployment]] 참고하자.
	- pod 복제본 수나, 배포 이력 관리하도록 한다.
2. Service 작성하기.
	- 서비스를 작성하여 열 수 있어야 한다.
		- 근데 서비스 pod를 그대로 외부로 노출시키는건 나쁜 Practice이다.
	- 여러가지 방법이 있는데, 인간적으로 이쯤되면 로드밸런서 쓰는게 맞지 않을까?
		- ClusterIP + Port Forwarding
		- NodePort
			- Pod에 직접 접근하도록 하는거 좋은 방법 아니라고 수십번은 말한 것 같다.
		- 위의 두 방식이 로컬에서 테스트할때는 사용할 수 있겠지만, 이걸로 서비스하면 신나는거다.
	- 외부로 노출시킬때는 다음과 같은 방법을 수행해야 한다.
		- Load Balancer
			- 클라우드 프로바이더에서 제공하는 로드밸런서를 사용하게 된다.
				- 일반적으로 이게 베스트 케이스다.
			- minikube에서도 addon을 통해 LoadBalancer 사용할 수 있다. [쿠버네티스 안내서](https://subicura.com/k8s/guide/service.html#service-nodeport-만들기)
		- Ingress
			- 트래픽에 대한 다양한 외부 접근을 관리하게 된다.
			- 일반적으로 Nginx를 컨트롤러를 이용해 사용하게 된다.
				- 그냥 클라우드 벤더에서 제공하는 ELB같은거 쓰는게 베스트긴 하다. [[K8s - Best Practices]]
				- 여튼 여기로 지정해서 사용할 수 있다.

## Simplifying Deployment Process
- 명령어 하나로 이러한 과정들을 모두 처리할 수 있도록 하면 참 좋을거다.
	- 당연히 개발자들은 답을 찾았다.? [[K8s - Continuous Integration and Deployment]]
	- 쿠버네티스를 이용한 빌드 / 배포 파이프라인에 대해 알아보자.

### Skaffold
- 구글에서 만든 쿠버네티스 개발 도구이다.
	- 로컬 환경에서 쿠베 개발 할때 초점으로 잡고 다양한 기능을 제공한다.
	- 굉장히 가볍다.
		- skaffold.yaml 하나로 작동시킬수 있고, yaml 문법 사용할 수 있다.

#### Pipeline Stages
- 빌드 / 배포의 전 과정을 각각의 단계로 쪼개두었다.
	- 각 단계가 별도의 스테이지로 존재하고, 서로 분리가 되어있다.
		- 각 단계의 세부 구현을 쉽게 바꿀 수 잇다.
		- 기존 배포를 kubectl로 하다가 Helm으로 바꾼다고 해도, 스테이지 설정만 변경하면 된다.
	- 각 스테이지를 따로 진행할 수도 있다.

#### skaffold.yaml
- 이미지를 빌드하는 방법 / 테스트하는 방법 / 배포하는 방법이 모두 이 파일에 작성된다.
- 기본적인 구조는 yaml이라, 일반적인 쿠버네티스 구조와 와꾸가 동일하다.
	- 키값에도 여러가지 값을 공유하여, 기본적인 구조는 쿠버네티스 오브젝트와 동일하다.
- 파일은 여러가지 섹션으로 구성되어 있다.
	- build
		- 이미지를 빌드하고 푸시하는 것에 대한 설정이 담겨있다.
			- 이미지를 어떻게 빌드할 것인지, 어떻게 태깅할 것인지 등이 담긴다

	- deploy
		- Pod, Deployment와 같은 리소스를 배포하는 것에 관한 설정이 담겨 있다.

	- profiles
		- 워크플로우를 실행할 때 프로파일에 따라 다른 기능을 수행할 수 있도록 한다.
	- test / portForward등의 설정도 존재한다.

### Build
- 이미지를 어떻게 빌드할 것인지를 관리하게 된다.
	- 빌드하고 push하는 것에 대한 정보가 담기게 된다.
- 이미지를 빌드할 때 같은 이미지의 서로 다른 버전을 식별하기 위해 태그를 사용한다.
	- tagPolicy 속성을 통해 이미지를 빌드할 때 어떤 태그를 사용할 것인지 명시할 수 있다.
	- skaffold에서는 같은 태그를 사용하더라도 이미지 다이제스트를 활용해 각 빌드마다 이미지를 고유하게 만든다
- 이미지를 빌드했다면 저장소로 올려야 한다.
	- 이미지를 저장하는 레지스트는 지정된 URL이 존재한다.
		- 이걸 skaffold의 image repository handling 기능을 통해 제어할 수 있다.
		- 환경 변수, default-repo, global config 등의 기능으로 올라가는 저장소를 설정할 수 있다.

### Image Deployment
- 배포 절차는 보통 다음과 같이 이루어진다.
	1. 배포하려는 쿠버네티스의 리소스의 설정을 적절히 변경한다.
	2. kubectl apply등의 명령을 통해 변경된 yaml 파일을 클러스터에 반양한다.
- 배포할 때 직접 YAML 파일을 수정하지 않도록 하는 것이 목적이다.
	- 배포될 때 YAML 파일에서 바뀌는 부분은 결국 사용하는 이미지이다.
	- Skaffold를 사용하여 배포하여, manifest 파일에 명시된 이미지와 이름이 일치하는 이미지를 찾아 대체하여 배포한다.

### Deployment Configuration
- 서비스 규모가 커지면 테스트 환경과 운영 환경을 다르게 가져간다.
	- 이런 환경을 스테이징 환경이라 하고, 필요에 따라 환경이 여러개로 늘어날 수 있다.
	- 환경에 따라 배포하는 코드도 달라지게 된다.
- Skaffold에서는 이를 profile을 통해 지원한다.
	- 프로필에 따라 기존의 세션의 값을 프로필에 정의된 값으로 대체하게 된다.